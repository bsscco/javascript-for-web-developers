Step1 <프론트엔드 개발자를 위한 자바스크립트 프로그래밍>

- 1장 자바스크립트란 무엇인가
  - ECMAScript(ES)
    - 기반언어
  - Javascript
    - 웹브라우저에서 ECMAScript를 구현한 언어
    - ECMAScript + DOM + BOM
  - NodeJS
    - 서버사이드에서 ECMAScript를 구현한 플랫폼
  - DOM
    - DOM은 문서를 표현하는 트리를 생성하고, 개발자는 DOM API를 통해 문서의 콘텐츠와 구조를 자유롭게 수정할 수 있다.
  - BOM
    - 브라우저창에 접근하고 조작할 수 있는 기술
- 2장 HTML 속의 자바스크립트
  - <script> 태그의 로딩
    - 여러 <script>가 있으면 위에서부터 순서대로 로딩된다.
    - <script> 태그에 defer 속성을 쓰면 페이지 렌더링 후에 로딩한다.
    - <script> 태그에 async 속성을 쓰면 비동기로 렌더링한다.
  - <script> 태그의 위치
    - <head></head> 안에 있으면 페이지 렌더링을 지연시킨다.
    - <body></body> 맨 끝에 넣으면 페이지 렌더링이 먼저 실행된다.
  - 외부파일(src속성)의 장점
    - js코드 관리가 쉽다.
    - 브라우저가 외부파일을 캐싱한다.
  - 문서모드 주의
    - 기본은 비표준 쿽스모드
    - HTML5에서 <!DOCTYPE html>로 시작하면 표준모드
  - <noscript> 태그
    - 자바스크립트 기능이 꺼졌거나 지원하지 않는 브라우저에서 <noscript></noscript> 안에 있는 내용을 보여주게 한다.
- 3장 언어의 기초
  - 문법
    - 스트릭트 모드
      - 파일이나 함수 첫줄에 "use strict"
      - 스트릭트 모드에서는 안전하지 않은 동작이 예상되는 곳에서 에러를 발생시킨다.
    - 문장의 끝에 세미콜론을 꼭 쓰자.
      - 세미콜론을 안 쓰면 자바스크립트 압축 과정에서 문제가 발생할 수 있다.
  - 변수
    - 함수에선 되도록 변수 선언에 var를 쓰자.
      - 의도를 명확히 할 수 있고, 실수를 예방한다.
  - 데이터타입
    - 원시타입
      - Boolean(true, false)
      - String("a", ...)
      - Number(1, 1.0, ...)
      - Object({a:1}, ...)
      - Null(null)
      - Undefined(undefined)
    - typeof 반환값
      - Boolean : "boolean"
      - String : "string"
      - Number(Infinity, -Infinity, NaN 포함) : "number"
      - Object(Null 포함) : "object"
      - Undefined : "undefined"
      - Function : "function"
    - Boolean() 반환값
      - Boolean : false -> false
      - String : "" -> false
      - Number
        - 0 -> false
        - NaN -> false
      - Object : null -> false
      - Undefined : 항상 -> false
    - 부동소수점 타입의 비교연산을 주의하자.
      - 0.1 + 0.2 == 0.3 // false
    - isNaN() 반환값
      - Boolean : 항상 -> false
      - String
        - "" -> false
        - 숫자로 만들 수 있으면 -> false
      - Number : NaN -> true
      - Object
        - null -> false
        - 그 외 -> valueOf() 값에 따라 결정
      - Undefined : 항상 -> true
    - Number() 함수의 반환값
      - Boolean
        - true -> 1
        - false -> 0
      - String
        - "" -> 0
        - 숫자로 만들 수 있으면 -> 숫자
        - 그 외 -> NaN
      - Number
        - 값 그대로
      - Object
        - null -> 0
        - 그 외 -> valueOf() 값
      - Undefined : 항상 -> NaN
    - 숫자 파싱 함수
      - 문자열을 숫자로 바꿀 때 사용한다.
      - 항상 10진수 기준으로 파싱한다.
      - parseInt() 반환값
        - "" -> NaN
        - "1234blue" -> 1234
        - "0xA" -> 10
        - parseInt(A, 16) -> 10
        - parseInt()의 두번째 매개변수(진법)를 꼭 넣자.
          - 혹시 모를 에러를 예방하기 위해
      - parseFloat() 반환값
        - "" -> NaN
        - "0xA" -> 0
        - "22.5.34" -> 22.5
        - "10.0" -> 10
        - parseFloat()은 진법 매개변수가 없다.
    - Number.toString() 반환값
      - 첫번째 매개변수(진법)에 따라 출력이 다르다.
      - n = 10;
      - n.toString() -> "10"
      - n.toString(2) -> "1010"
      - n.toString(5) -> "20"
    - String() 반환값
      - 항상 문자열을 반환한다.
      - Boolean : 항상 -> "불리언값"
      - Number : 항상 -> "숫자값"
      - String : 항상 -> 값 그대로
      - Object
        - null -> "null"
        - 그 외 -> toString() 값
      - Undefined :  항상 -> "undefined"
    - Object
      - 모든 객체의 원형
      - 메소드
        - constructor() : 생성자
        - hasOwnProperty(propertyName) : 
        - isPrototypeOf(object)
        - propertyIsEnumerable(propertyName)
        - toLocaleString()
        - toString()
        - valueOf()
    - 비트 연산자(|, &, >>, <<, >>>, <<<)
      - 양의 정수 10의 표현은 1010
      - 음의 정수 10의 표현은 1010 -> 1의 보수 -> 1 더하기
      - Number(10).toString(2) -> "1010"
      - Number(-10).toString(2) -> "-1010"
      - 비트 NOT 연산자의 반환값
        - 숫자 부호를 바꾼 후 1을 뺀 결과
        - ~25 // -26
        - ~-26 // 25
      - 시프트 연산자의 반환값
        - 2 << 5 // 64 = 2^6
        - 64 >> 5 // 2 = 2^1
    - 논리 연산자(!, &&, ||)
      - 논리 NOT 연산자의 반환값
        - Boolean()의 반대값
      - 논리 AND 연산자의 반환값
        - Boolean(첫번째 피연산자)가 true면 -> 두번째 피연산자를 반환
        - Boolean(첫번째 피연산자)가 false면 -> 첫번째 피연산자를 반환
      - 논리 OR 연산자의 반환값U
        - Boolean(첫번째 피연산자)가 true면 -> 첫번째 피연산자를 반환
        - Boolean(첫번째 피연산자)가 false면 -> 두번째 피연산자를 반환
    - 비교 연산자(<=, >=, <, >)의 반환값
      - isNaN(두 피연산자)이 false면 -> 숫자로 바꾸어 비교한다.
      - isNaN(두 피연산자)이 true이고 피연산자 둘 다 문자열이면 -> 아스키코드값으로 비교한다.
      - isNaN(두 피연산자)에서 하나는 false이고 하나는 객체면 -> 객체의 valueOf()와 비교한다.
      - isNaN(두 피연산자)에서 하나라도 true면 -> 항상 false
    - 동일 연산자(==)의 반환값
      - 피연산자를 비교하기 전에 타입을 강제변환 시킨다. (type coercion)
      - isNaN(두 피연산자)이 false면 -> 숫자로 바꾸어 비교한다.
      - isNaN(두 피연산자)이 true이고 피연산자 둘 다 문자열이면 -> 아스키코드값으로 비교한다.
      - isNaN(두 피연산자)에서 하나는 false이고 하나는 객체면 -> 객체의 valueOf()와 비교한다.
      - isNaN(두 피연산자)에서 하나라도 true면 -> 항상 false
      - 두 피연산자가 모두 객체면 -> 두 객체의 참조로 비교한다.
      - 예외적으로 null, undefined는 -> 다른 값으로 변환하지 않고 비교한다.
      - 예외적으로 null == undefined -> true
    - 일치 연산자(===)의 반환값
      - 타입을 강제변환 시키지 않고 비교한다.
      - 두 피연산자가 모두 객체면 -> 두 객체의 참조로 비교한다.
      - 예상하기 어려운 에러 발생을 예방하기 위해 일치 연산자를 쓰자.
    - 
  - 문장
    - with문의 성능
      - 성능에 악영향이 있고 디버깅도 어렵기 때문에 쓰지 않는 게 좋다.
    - switch문의 유연함
      - case절에 표현식을 쓸 수 있어서 유연하다.
  - 함수
    - 매개변수가 유연하다.
      - js의 함수 매개변수는 arguments라는 배열로 들어오기 때문에 시그니처에서 선언된 개수와 상관 없이 매개변수를 마음대로 넘길 수 있다.
      - function fun(a, b) {...} 에서 arguments[1] = 10으로 바꾸면 b도 10이 된다. 하지만 b = 20으로 바꾸면 arguments[1]은 바뀌지 않는다. arguments에서 이름붙은 매개변수로의 단방향 반영이기 때문이다.
    - 오버로딩이 없다.
      - 함수명만 같으면 마지막 함수가 이전 함수를 덮어쓴다.
- 4장 변수와 스코프, 메모리
  - 원시값과 참조값
    - 종류
      - 원시값 : 원시타입의 값, String도 원시값
        - 스택에 저장된다.
      - 참조값 : 객체
        - 힙에 저장된다.
    - 동적 프로퍼티는 객체만 가질 수 있다.
      - name = "Coo";
      - name.age = 27; 
      - alert(name.age); // "undefined"
    - 원시값은 값복사, 참조값은 참조복사
    - typeof와 instanceof
      - 원시값의 타입판별은 typeof로 충분하다.
      - 참조값의 타입판별은 instanceof로 한다.
      - 원시값에 instanceof를 사용하면 항상 -> false
    - typeof Boolean(), String(), Number() vs typeof new Boolean(), new String(), new Number()
      - "boolean" vs "object"
      - "string" vs "object"
      - "number" vs "object"
  - 실행 컨텍스트와 스코프
    - 전역 컨텍스트
      - 웹브라우저에서는 window라고 부른다.
    - 함수 컨텍스트
      - 함수를 실행하면 컨텍스트스택에 함수 컨텍스트가 쌓인다.
    - 문장 컨텍스트
      - 중괄호가 예약어 if 뒤에 쓰였다면 문장 컨텍스트
    - 표현식 컨텍스트
      - 중괄호가 할당 연산자 뒤에 쓰였다면 (객체 리터럴 표기법) 표현식 컨텍스트
    - 스코프체인
      - 코드를 실행하면 변수객체에 스코프체인이 만들어지는데, 스코프체인의 맨 뒷쪽에 있는 전역 컨텍스트까지 식별자 이름을 검색한다.
    - 다른 언어와 달리 블록레벨 스코프가 없다.
  - 가비지 컬렉션
    - mark and sweep
      - 현재 사용하지 않는 값에 표시를 남겨서 메모리를 회수하는 방식
    - reference counting
      - 순환참조의 문제가 있어서 모든 웹브라우저는 mark and sweep을 사용한다.
  - 메모리 관리
    - 웹브라우저의 가용 메모리는 데스크탑 가용 메모리에 비해 적다. 웹브라우저가 시스템 메모리를 전부 사용해서 운영체제를 다운시키는 일을 방지하기 위해
    - 전역변수의 사용을 마치면 null처리 해주는 게 좋다.
- 5장 참조타입
  - Object 타입
    - 객체 생성
      - 객체를 생성할 땐 new 연산자 뒤에 생성자(팩토리 함수) Object()를 쓴다.
      - 어파치 생성되는 게 객체라서 new는 생략해도 똑같다.
    - 객체 리터럴 표기법의 장점
      - o = {a:1,b:2}
      - 여러 프로퍼티를 가진 객체를 쉽게 정의할 수 잇도록 디자인된 표기법
      - 함수에 옵션 매개변수를 여러 개 넘길 때 유용하다.
    - 객체 프로퍼티에 접근하는 방법
      - 점. 표기법
        - 일반적인 접근법
      - 대괄호[] 표기법
        - 프로퍼티 이름에 변수가 필요할 때나 프로퍼티 이름에 문법에러를 일으키는 문자가 들어있을 때만 쓰는 게 좋다.
  - Array 타입
    - 객체 생성
      - a = new Array(), a = []
      - 어파치 생성되는 게 객체라서 new는 생략해도 똑같다.
    - 생성자 매개변수
      - a = new Array(3) // 길이가 3인 배열
      - a = new Array(1, 2) // 길이가 2인 배열
    - 객체 접근법
      - a.[index]
      - 인덱스에 길이보다 큰 값을 넣어서 쓰면 배열의 길이가 늘어난다.
      - a.length값을 바꿔도 새 값에 따라 길이가 조절된다.
    - 프레임이 여러 개일 때 배열 감지
      - 프레임이 2개라면 Array 생성자도 2개다.
      - 배열을 한 프레임에서 다른 프레임으로 전달했다면 다른 생성자 함수를 가지기 때문에 instanceof Array 표현식이 원하는 값을 반환하지 않는다.
      - ES5에서는 Array.isArray() 메서드를 제공한다. 주어진 값이 배열인지 아닌지 실행 컨텍스트와 상관 없이 알려준다.
    - 다른 자료구조처럼 동작
      - 스택
        - 뒤에서 넣고 push(), 뒤에서 뺀다 pop()
      - 큐
        - 뒤에서 넣고 push(), 앞에서 뺀다 shift()
      - 데크
        - 뒤에서 넣고 push(), 앞에서 뺀다 shift, 앞에서 넣고 unshift(), 앞에서 넣고 unshift(), 뒤에서 뺀다 pop()
    - 정렬
      - sort(), reverse()
      - 각 데이터를 String()을 통해 문자열로 변환 후 비교하므로 숫자로만 이루어진 배열도 상식적이지 않은 결과를 낼 수 있다. 이런 경우 비교 함수를 넣어 비교하게 할 수 있다.
    - 배열 조작
      - concat()
        - 원본 배열을 복사해서 새 배열을 반환한다.
        - 매개변수가 배열이든 값이든 새 배열에 뒤에 추가한다.
      - slice()
        - 원본 배열의 일부를 복사해서 새 배열로 반환한다.
        - 배개변수로 음수를 넘길 수 있다.
      - splice()
        - 삭제된 배열이 있으면 삭제된 배열을 반환한다. 삭제된 배열이 없으면 빈 배열을 반환한다.
        - 부분 삭제(매개변수 2개)
        - 부분 삽입(매개변수 3개 이상)
        - 부분 대체(매개변수 3개 이상)
    - 위치 알아내기
      - ES5부터 적용
      - indexOf()
      - lastIndexOf()
    - 반복
      - ES5부터 적용
      - some() -> boolean
      - every() -> boolean
      - filter() -> new []
      - forEach() -> undefined
      - map() -> new []
    - 배열을 하나의 값으로 만들기
      - reduce()
        - 배열의 처음부터 마지막 순으로 순회
      - reduceRight()
        - 배열의 마지막에서 처음 순으로 순회
  - Date 타입
    - 객체 생성
      - new Date()
      - 어파치 생성되는 게 객체라서 new는 생략해도 똑같다.
    - 문자열을 Date 객체로
      - 생성자 매개변수로, 또는 Date.parse(), Date.UTC()
      - parse() 매개변수 포맷
        - 월/일/년(1/14/2004)
        - 월이름 일, 년(January 14, 2004)
        - 요일 월이름 일 년 시:분:초 타임존(Tue January 14 2004 00:00:00 GMT-0700)
        - YYYY-MM-DDTHH:mm:ss.sssZ(2004-01-14T00:00:00)
        - 올바른 포맷이 아니면 NaN를 반환한다.
      - UTC() 매개변수 포맷
        - 필수 매개변수는 년과 월
        - Date.UTC(2005, 4, 5, 17, 55, 55) // 2005년 5월 5일 5시 55분 55초
        - Date.UTC(2005, 4) // 2005년 5월 1일 0시 0분 0초
      - 생성자 매개변수에 parse() 포맷의 문자열을 넘기면 parse()를 호출하고, UTC() 포맷의 문자열을 넘기면 UTC()를 호출한다.
      - GTM과 UTC는 초의 소수점 단위에서만 차이가 나기 때문에 거의 같다고 보면 된다. UTC가 표준인데 아직 GMT도 많이 쓰이고 있다.
    - ES5에서 추가된 현재 시간
      - Date.now()
    - 오버로딩 메소드
      - toLocaleString() -> 지역에 맞춘 시간 설명
      - toString() -> 시간 설명
      - valueOf() -> 1970.1.1 이후 밀리초
    - 기타 날짜 표시
      - toDateString()
      - toTimeString()
      - toLocaleDateString()
      - toLocaleTimeString()
      - toUTCString()
    - 시간 getter/setter
      - getXXX(), getUTCXXX(), setXXX(), setUTCXXX()
